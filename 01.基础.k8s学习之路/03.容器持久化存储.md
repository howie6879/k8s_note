# 容器持久化存储

容器的本质是进程，对于进程，`Linux`系统有进程组的概念来将其组织在一起。在`k8s`里面，使用`Pod`这个逻辑概念来维护容器间的关系。

![img](https://gitee.com/howie6879/oss/raw/master/uPic/16c095d6efb8d8c226ad9b098689f306.png)

有了`Pod`后，我们的应用程序需要被创建和管理，这就引出了`ReplicaSet`和`Deployment`；然后需要将部署好的应用暴露给外部进行访问，`Service`可以提供一个固定的ip和端口让外部访问。

对于有状态的应用，可以使用`StatefulSet`来进行状态的恢复，在上一节[概念介绍](https://www.howie6879.cn/p/k8s%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.02.%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/)里面有提到，有状态的应用是离不开**持久化存储**的。

## 引子

在`Docker`中，如果一个容器在运行过程中会产生数据并写入到文件系统，当关闭这个容器，用镜像再启动一个容器的时候，你就会意识到新容器并不会识别前一个容器写入文件系统内的任何内容。

对于有状态的应用，我们希望下次启动的应用可以保持住上次的状态；在`k8s`里面通过定义**存储卷**来满足这个需求，它们不像`Pod`这样的顶级资源，而是被定义为`Pod`的一部分，并和`Pod`共享相同的生命周期。

因此在`Pod`里面容器重新启动期间，卷的内容是不变的，

## 参考

本章的基本概念就介绍到这里了，谢谢！本部分内容有参考如下文章：

- [深入剖析Kubernetes](https://time.geekbang.org/column/intro/100015201?code=UhApqgxa4VLIA591OKMTemuH1%2FWyLNNiHZ2CRYYdZzY%3D)：持久化存储部分
- [Kubernetes in Action](https://github.com/luksa/kubernetes-in-action)中文版：第6章

