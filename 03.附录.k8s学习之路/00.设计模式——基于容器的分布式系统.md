# 设计模式——基于容器的分布式系统

20世纪80年代末至90年代初，面向对象编程思想给软件开发带来了一轮技术革新，就像润物细无声的春雨那般，向全世界的程序员们快速普及了模块化构建应用程序的方法，一直流行至今。

当下，我们可以看到类似的革新出现在了分布式系统开发，具体特点如下：

- 基于容器的微服务架构体系日益流行
- 容器天然隔离的属性非常适合作为分布式系统中的**基本对象**

基于面向对象，**四人帮**基于经验提出和总结了对于一些常见软件设计问题的标准解决方案，其描述了一系列基于接口的模式，可以在各种环境中重用，这被称之为软件设计模式。历史一定程度上来说是重复的，随着这种架构模式的成熟，基于容器的分布式系统的设计模式也就自然而然地浮现了。

本篇主要阐述的是`Brendan Burns`在基于容器的分布式系统中发现的三种设计模式：

- single-container patterns for container management：容器管理之单容器模式
- single-node patterns of closely cooperating containers：容器协调之单节点（多容器）模式
- multi-node patterns for distributed algorithms：分布式算法之多节点模式

基于容器分布式系统的设计模式会给分布式计算编码带来以下优势：

- 最佳实践，给没有经验的程序员带来相对正确的使用方式
- 简化开发
- 提升系统可靠性

## 模式的价值

模式的目的是提供一般建议或结构来指导设计，这样做的好处有以下三点：

- 站在巨人的肩膀上，对于经验不怎么丰富的开发者，可以通过模式来指引走在正确的道路上，从而少采坑，提升项目质量
- 提供通用的名称和定义，有共同的领域语言进行交流是一件很重要的事情
- 方便识别并构建共享的通用组件

## 单容器模式

就像对象会定义边界一样，容器为定义接口提供了天然的边界；它不仅可以暴露特定应用的功能，还可以通过钩子函数来管理系统。传统的容器管理接口是极其有限的，如：

- run
- pause
- stop

这些接口只能说满足基础的使用需求，但是就目前的现状来看，更丰富的接口可以为系统开发者与操作者提供更多的功能。鉴于`HTTP`和`JSON`的普及程度，可以考虑通过容器在特定的节点托管一个`Web`服务来实现。这样做的目的是什么，可以从下面两个角度来看待：

- upward：容器可以暴露丰富的应用信息，比如：
  - 各类监控指标（QPS、应用健康等）
  - 一些开发人员感兴趣的信息如（线程、堆栈、锁、网络消息统计等）
  - 组件配置、日志等
- downward：任何开发者在编写软件组件的时候，都可以使用容器原生支持的生命周期接口来进行管控。比如一个集群管理系统通常会给任务分配对应的**优先级**，高优先级的任务即使在集群被超额订阅的情况下也能保证运行，这种保证是通过逐出已经运行的低优先级任务来实现的，然后这些低优先级任务能否运行取决于后面是否还有资源分配过来；但是这样有个问题就是开发者需要承担一些没必要的复返，比如处理一些优先级比较低的任务被*抛弃*的情况。相反，如果在应用程序和管理系统之间定义了正式的生命周期，那么应用程序组件将变得更易于管理，比如`k8s`使用`Docker` 的`graceful deletion`功能，这就允许应用程序通过完成当前任务，把状态写入磁盘等等操作之后再终止，将这个功能扩展一下就可以使使有状态的分布式系统的状态管理更加容易。

## 单节点（多容器）模式

上面提到了单容器的接口，我们稍稍延伸一下，对于一个多容器组成的应用，会有怎样的设计模式呢？当然，此时我们仍旧有些限制条件需要讲清楚：

- 容器都处于**单节点**下
- 容器管理系统需要支持将多容器作为原子单元协调编排，这也侧面印证为什么`k8s`需要有`Pod`这个逻辑概念

### 边车模式（Sidecar pattern）

> 扩展和增强现有的应用容器

目前最常见的多容器部署模式就是边车模式，边车模式就是由两个容器组成的单节点模式：

- 核心是应用程序容器，这个就是应用程序的轴心
- 其次就是边车容器，作用就是改进和增强应用程序容器

![image-20210310145212203](https://gitee.com/howie6879/oss/raw/master/uPic/image-20210310145212203.png)

边车模式的一般方式如上图所示，可以看到应用程序容器和边车容器共享了许多资源：

- 部分文件系统
- 主机名
- 网络
- 其他

我们通过下面的例子来看一下边车容器存在的必要性以及好处，图示如下：

![image-20210310152144189](https://gitee.com/howie6879/oss/raw/master/uPic/image-20210310152144189.png)

其中主容器是一个`web`服务，而`日志处理`边车容器的工作就是收集本地磁盘的服务器日志，并将其流式传输至存储集群，这样做的好处有：

- 容器是资源计算和调度的基本单位，所以可以优先配置主`Web`服务器的`cgroup`使得其处理延时降低，而日志处理容器则在`web`服务器空闲时使用`cpu`时间片进行日志处理
- 将模块化和可重用的组件封装成边车，可达到功能内聚，应用可被划分明确的边界进行解耦（方便接入、测试调试、状态处理等），最重要的是可以被不同主容器作为边车容器复用

### 大使模式（Ambassadors pattern）

> 改变和管理应用容器与外部世界的通信方式

第一次看大使模式，很可能会想这不就是另一种形式的边车模式吗？其实不然，首先第一点，大使模式下所有的请求响应信息交换全部是大使容器来完成的，应用程序容器只能和大使容器进行*交流*。

![image-20210310213608329](https://gitee.com/howie6879/oss/raw/master/uPic/image-20210310213608329.png)

这种模式主要利用的特性是**同一`Pod`中的容器可以共享相同的`localhost`网络接口**，而且可以从两个角度看大使容器：

- 内到外：让我们以访问一个存储区域为例，假设该存储区域的大小不断增长，必须分成更多的子系统。在这种情况下，为了不干预主容器并且必须对所有受影响的服务实施相同的新访问逻辑，创建一个大使容器来调解对存储区域的访问是个不错的选择
- 外到内：让我们设想一下，我们要测试微服务的新版本，可以通过大使容器控制请求量到相关部署

![Image for post](https://gitee.com/howie6879/oss/raw/master/uPic/1*-aeeNrASuzA8SMkOxyhmcw.png)

### 适配器模式（Adapter pattern）

> 确保应用程序实现统一的监控接口

真实世界的应用程序大概率会有出现下面列出的几种情况：

- 一部分服务自行开发（可能有新老标准差异），一部分使用开源项目
- 服务的编写语言多样，日志记录、监控也多样

假设我们需要有效地监控和运维应用程序，这就要求应用程序可以提供统一的通用接口来进行指标收集。这就是适配器发挥作用的场景了，对于不同应用容器提供的不同接口，可以使用适配器适配这种异构性并转化为一致的接口且原有服务代码不需要做任何改动。

![image-20210310222109600](https://gitee.com/howie6879/oss/raw/master/uPic/image-20210310222109600.png)

主应用程序通过`localhost`或者`volume`与适配器容器通信，适配器经过一层处理提供统一的输出给外部使用者，一些常用的使用场景如下：

- 监控：适配器将应用程序容器公开的监控接口转换为通用监控系统所期望的接口
- 日志：适配器提供统一的日志记录输出

## 多节点模式

不要将模块化容器局限于单机容器协调上，其实模块化容器还可以使构建协调的多节点分布式应用程序变得更加容易。接下来将描述其中的三种分布式系统模，与前一节中的模式一样，这些模式也需要对 `Pod` 这个逻辑概念的支持。

### 领导选举模式（Leader election pattern）

### 工作队列模式（Work queue pattern）

### 分散/聚集模式（Scatter/gather pattern）

## 说明

主体内容来自：

- 论文《[Design patterns for container-based distributed systems](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45406.pdf)》
- 书籍《[Designing Distributed Systems](https://book.douban.com/subject/34844678/)》

最近一直在了解低代码开发平台相关知识，就是前面提到的[一站式机器学习云研发平台](https://www.howie6879.cn/p/%E4%B8%80%E7%AB%99%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BA%91%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/)，其中关于资源管理这块离不开`k8s`的使用，因此花了不少精力在这上面，遂将学习过程整理成了教程：

- 01.走进Kubernetes
- 02.概念介绍
- 03.容器持久化存储
- 04.容器网络

更多详见我博客上关于[k8s学习之路](https://www.howie6879.cn/categories/k8s/)系列。
